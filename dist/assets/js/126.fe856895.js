(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{637:function(e,a,s){"use strict";s.r(a);var t=s(11),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("blockquote",[s("p",[e._v("本文由 "),s("a",{attrs:{href:"http://ksria.com/simpread/",target:"_blank",rel:"noopener noreferrer"}},[e._v("简悦 SimpRead"),s("OutboundLink")],1),e._v(" 转码， 原文地址 "),s("a",{attrs:{href:"https://www.jianshu.com/p/2217cfed29d7",target:"_blank",rel:"noopener noreferrer"}},[e._v("www.jianshu.com"),s("OutboundLink")],1)])]),e._v(" "),s("p",[e._v("先来看一份 docker-compose.yml 文件，不用管这是干嘛的，只是有个格式方便后文解说：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("version: '2'\nservices:\n  web:\n    image: dockercloud/hello-world\n    ports:\n      - 8080\n    networks:\n      - front-tier\n      - back-tier\n\n  redis:\n    image: redis\n    links:\n      - web\n    networks:\n      - back-tier\n\n  lb:\n    image: dockercloud/haproxy\n    ports:\n      - 80:80\n    links:\n      - web\n    networks:\n      - front-tier\n      - back-tier\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock \n\nnetworks:\n  front-tier:\n    driver: bridge\n  back-tier:\ndriver: bridge \n")])])]),s("p",[e._v("可以看到一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，下面先来看 services 的书写规则。")]),e._v(" "),s("h2",{attrs:{id:"_1-image"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-image"}},[e._v("#")]),e._v(" 1.image")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("services:\n  web:\n    image: hello-world \n")])])]),s("p",[e._v("在 services 标签下的第二级标签是 web，这个名字是用户自己自定义，它就是服务名称。"),s("br"),e._v("\nimage 则是指定服务的镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。"),s("br"),e._v("\n例如下面这些格式都是可以的：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("image: redis\nimage: ubuntu:14.04\nimage: tutum/influxdb\nimage: example-registry.com:4000/postgresql\nimage: a4bc65fd \n")])])]),s("h2",{attrs:{id:"_2-build"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-build"}},[e._v("#")]),e._v(" 2.build")]),e._v(" "),s("p",[e._v("服务除了可以基于指定的镜像，还可以基于一份 Dockerfile，在使用 up 启动之时执行构建任务，这个构建标签就是 build，它可以指定 Dockerfile 所在文件夹的路径。Compose 将会利用它自动构建这个镜像，然后使用这个镜像启动服务容器。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("build: /path/to/build/dir \n")])])]),s("p",[e._v("也可以是相对路径，只要上下文确定就可以读取到 Dockerfile。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("build: ./dir \n")])])]),s("p",[e._v("设定上下文根目录，然后以该目录为准指定 Dockerfile。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("build:\n  context: ../\n  dockerfile: path/of/Dockerfile \n")])])]),s("p",[e._v("注意 build 都是一个目录，如果你要指定 Dockerfile 文件需要在 build 标签的子级标签中使用 dockerfile 标签指定，如上面的例子。"),s("br"),e._v("\n如果你同时指定了 image 和 build 两个标签，那么 Compose 会构建镜像并且把镜像命名为 image 后面的那个名字。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("build: ./dir\nimage: webapp:tag \n")])])]),s("p",[e._v("既然可以在 docker-compose.yml 中定义构建任务，那么一定少不了 arg 这个标签，就像 Dockerfile 中的 ARG 指令，它可以在构建过程中指定环境变量，但是在构建成功后取消，在 docker-compose.yml 文件中也支持这样的写法：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("build:\n  context: .\n  args:\n    buildno: 1\n    password: secret \n")])])]),s("p",[e._v("下面这种写法也是支持的，一般来说下面的写法更适合阅读。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("build:\n  context: .\n  args:\n    - buildno=1\n    - password=secret \n")])])]),s("p",[e._v("与 ENV 不同的是，ARG 是允许空值的。例如：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("args:\n  - buildno\n  - password \n")])])]),s("p",[e._v("这样构建过程可以向它们赋值。")]),e._v(" "),s("blockquote",[s("p",[e._v("注意：YAML 的布尔值（true, false, yes, no, on, off）必须要使用引号引起来（单引号、双引号均可），否则会当成字符串解析。")])]),e._v(" "),s("h2",{attrs:{id:"_3-command"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-command"}},[e._v("#")]),e._v(" 3.command")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("使用 command 可以覆盖容器启动后默认执行的命令。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("command: bundle exec thin -p 3000 \n")])])]),s("p",[e._v("也可以写成类似 Dockerfile 中的格式：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("command: [bundle, exec, thin, -p, 3000] \n")])])]),s("h2",{attrs:{id:"_4-container-name"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-container-name"}},[e._v("#")]),e._v(" 4.container_name")]),e._v(" "),s("p",[e._v("前面说过 Compose 的容器名称格式是：<项目名称>"),s("em",[e._v("<服务名称>")]),e._v("<序号>"),s("br"),e._v("\n虽然可以自定义项目名称、服务名称，但是如果你想完全控制容器的命名，可以使用这个标签指定：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("container_name: app \n")])])]),s("p",[e._v("这样容器的名字就指定为 app 了。")]),e._v(" "),s("h2",{attrs:{id:"_5-depends-on"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-depends-on"}},[e._v("#")]),e._v(" 5.depends_on")]),e._v(" "),s("p",[e._v("在使用 Compose 时，最大的好处就是少打启动命令，但是一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。"),s("br"),e._v("\n例如在没启动数据库容器的时候启动了应用容器，这时候应用容器会因为找不到数据库而退出，为了避免这种情况我们需要加入一个标签，就是 depends_on，这个标签解决了容器的依赖、启动先后的问题。"),s("br"),e._v("\n例如下面容器会先启动 redis 和 db 两个服务，最后才启动 web 服务：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("version: '2'\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n  redis:\n    image: redis\n  db:\n    image: postgres \n")])])]),s("p",[e._v("注意的是，默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系。")]),e._v(" "),s("h2",{attrs:{id:"_6-dns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-dns"}},[e._v("#")]),e._v(" 6.dns")]),e._v(" "),s("p",[e._v("和 --dns 参数一样用途，格式如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("dns: 8.8.8.8 \n")])])]),s("p",[e._v("也可以是一个列表：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("dns:\n  - 8.8.8.8\n  - 9.9.9.9 \n")])])]),s("p",[e._v("此外 dns_search 的配置也类似：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("dns_search: example.com\ndns_search:\n  - dc1.example.com\n  - dc2.example.com \n")])])]),s("ol",{attrs:{start:"7"}},[s("li",[e._v("tmpfs")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("挂载临时目录到容器内部，与 run 的参数一样效果：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tmpfs: /run\ntmpfs:\n  - /run\n  - /tmp \n")])])]),s("ol",{attrs:{start:"8"}},[s("li",[e._v("entrypoint")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("在 Dockerfile 中有一个指令叫做 ENTRYPOINT 指令，用于指定接入点，第四章有对比过与 CMD 的区别。"),s("br"),e._v("\n在 docker-compose.yml 中可以定义接入点，覆盖 Dockerfile 中的定义：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("entrypoint: /code/entrypoint.sh \n")])])]),s("p",[e._v("格式和 Docker 类似，不过还可以写成这样：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("entrypoint:\n    - php\n    - -d\n    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so\n    - -d\n    - memory_limit=-1\n    - vendor/bin/phpunit \n")])])]),s("h2",{attrs:{id:"_9-env-file"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-env-file"}},[e._v("#")]),e._v(" 9.env_file")]),e._v(" "),s("p",[e._v("还记得前面提到的 .env 文件吧，这个文件可以设置 Compose 的变量。而在 docker-compose.yml 中可以定义一个专门存放变量的文件。"),s("br"),e._v("\n如果通过 docker-compose -f FILE 指定了配置文件，则 env_file 中路径会使用配置文件路径。")]),e._v(" "),s("p",[e._v("如果有变量名称与 environment 指令冲突，则以后者为准。格式如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("env_file: .env \n")])])]),s("p",[e._v("或者根据 docker-compose.yml 设置多个：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("env_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env \n")])])]),s("p",[e._v("注意的是这里所说的环境变量是对宿主机的 Compose 而言的，如果在配置文件中有 build 操作，这些变量并不会进入构建过程中，如果要在构建中使用变量还是首选前面刚讲的 arg 标签。")]),e._v(" "),s("ol",{attrs:{start:"10"}},[s("li",[e._v("environment")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("与上面的 env_file 标签完全不同，反而和 arg 有几分类似，这个标签的作用是设置镜像变量，它可以保存变量到镜像里面，也就是说启动的容器也会包含这些变量设置，这是与 arg 最大的不同。"),s("br"),e._v("\n一般 arg 标签的变量仅用在构建过程中。而 environment 和 Dockerfile 中的 ENV 指令一样会把变量一直保存在镜像、容器中，类似 docker run -e 的效果。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("environment:\n  RACK_ENV: development\n  SHOW: 'true'\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SHOW=true\n  - SESSION_SECRET \n")])])]),s("ol",{attrs:{start:"11"}},[s("li",[e._v("expose")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("这个标签与Dockerfile中的EXPOSE指令一样，用于指定暴露的端口，但是只是作为一种参考，实际上docker-compose.yml的端口映射还得ports这样的标签。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('expose:\n - "3000"\n - "8000" \n')])])]),s("ol",{attrs:{start:"12"}},[s("li",[e._v("external_links")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("在使用Docker过程中，我们会有许多单独使用docker run启动的容器，为了使Compose能够连接这些不在docker-compose.yml中定义的容器，我们需要一个特殊的标签，就是external_links，它可以让Compose项目里面的容器连接到那些项目配置外部的容器（前提是外部容器中必须至少有一个容器是连接到与项目内的服务的同一个网络里面）。"),s("br"),e._v("\n格式如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("external_links:\n - redis_1\n - project_db_1:mysql\n - project_db_1:postgresql \n")])])]),s("ol",{attrs:{start:"13"}},[s("li",[e._v("extra_hosts")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker client的--add-host类似：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('extra_hosts:\n - "somehost:162.242.195.82"\n - "otherhost:50.31.209.229" \n')])])]),s("p",[e._v("启动之后查看容器内部hosts：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("162.242.195.82  somehost\n50.31.209.229   otherhost \n")])])]),s("ol",{attrs:{start:"14"}},[s("li",[e._v("labels")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("向容器添加元数据，和Dockerfile的LABEL指令一个意思，格式如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('labels:\n  com.example.description: "Accounting webapp"\n  com.example.department: "Finance"\n  com.example.label-with-empty-value: ""\nlabels:\n  - "com.example.description=Accounting webapp"\n  - "com.example.department=Finance"\n  - "com.example.label-with-empty-value" \n')])])]),s("ol",{attrs:{start:"15"}},[s("li",[e._v("links")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("还记得上面的depends_on吧，那个标签解决的是启动顺序问题，这个标签解决的是容器连接问题，与Docker client的--link一样效果，会连接到其它服务中的容器。"),s("br"),e._v("\n格式如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("links:\n - db\n - db:database\n - redis \n")])])]),s("p",[e._v("使用的别名将会自动在服务容器中的/etc/hosts里创建。例如：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("172.12.2.186  db\n172.12.2.186  database\n172.12.2.187  redis \n")])])]),s("p",[e._v("相应的环境变量也将被创建。")]),e._v(" "),s("ol",{attrs:{start:"16"}},[s("li",[e._v("logging")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("这个标签用于配置日志服务。格式如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('logging:\n  driver: syslog\n  options:\n    syslog-address: "tcp://192.168.0.42:123" \n')])])]),s("p",[e._v("默认的driver是json-file。只有json-file和journald可以通过docker-compose logs显示日志，其他方式有其他日志查看方式，但目前Compose不支持。对于可选值可以使用options指定。"),s("br"),e._v("\n有关更多这方面的信息可以阅读官方文档："),s("br"),e._v(" "),s("a",{attrs:{href:"https://link.jianshu.com?t=https://docs.docker.com/engine/admin/logging/overview/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://docs.docker.com/engine/admin/logging/overview/"),s("OutboundLink")],1)]),e._v(" "),s("ol",{attrs:{start:"17"}},[s("li",[e._v("pid")])]),e._v(" "),s("hr"),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('pid: "host" \n')])])]),s("p",[e._v("将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。")]),e._v(" "),s("ol",{attrs:{start:"18"}},[s("li",[e._v("ports")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("映射端口的标签。"),s("br"),e._v("\n使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('ports:\n - "3000"\n - "8000:8000"\n - "49100:22"\n - "127.0.0.1:8001:8001" \n')])])]),s("blockquote",[s("p",[e._v("注意：当使用HOST:CONTAINER格式来映射端口时，如果你使用的容器端口小于60你可能会得到错误得结果，因为YAML将会解析xx:yy这种数字格式为60进制。所以建议采用字符串格式。")])]),e._v(" "),s("ol",{attrs:{start:"19"}},[s("li",[e._v("security_opt")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("为每个容器覆盖默认的标签。简单说来就是管理全部服务的标签。比如设置全部服务的user标签值为USER。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("security_opt:\n  - label:user:USER\n  - label:role:ROLE \n")])])]),s("ol",{attrs:{start:"20"}},[s("li",[e._v("stop_signal")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("设置另一个信号来停止容器。在默认情况下使用的是SIGTERM停止容器。设置另一个信号可以使用stop_signal标签。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("stop_signal: SIGUSR1 \n")])])]),s("ol",{attrs:{start:"21"}},[s("li",[e._v("volumes")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER] 这样的格式，或者使用 [HOST:CONTAINER:ro] 这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统。"),s("br"),e._v("\nCompose的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。"),s("br"),e._v("\n数据卷的格式可以是下面多种形式：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("volumes:\n  // 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。\n  - /var/lib/mysql\n\n  // 使用绝对路径挂载数据卷\n  - /opt/data:/var/lib/mysql\n\n  // 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。\n  - ./cache:/tmp/cache\n\n  // 使用用户的相对路径（~/ 表示的目录是 /home/<用户目录>/ 或者 /root/）。\n  - ~/configs:/etc/configs/:ro\n\n  // 已经存在的命名的数据卷。\n  - datavolume:/var/lib/mysql \n")])])]),s("p",[e._v("如果你不使用宿主机的路径，你可以指定一个volume_driver。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("volume_driver: mydriver \n")])])]),s("ol",{attrs:{start:"22"}},[s("li",[e._v("volumes_from")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("从其它容器或者服务挂载数据卷，可选的参数是 :ro或者 :rw，前者表示容器只读，后者表示容器对数据卷是可读可写的。默认情况下是可读可写的。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("volumes_from:\n  - service_name\n  - service_name:ro\n  - container:container_name\n  - container:container_name:rw \n")])])]),s("ol",{attrs:{start:"23"}},[s("li",[e._v("cap_add, cap_drop")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("添加或删除容器的内核功能。详细信息在前面容器章节有讲解，此处不再赘述。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("cap_add:\n  - ALL\n\ncap_drop:\n  - NET_ADMIN\n  - SYS_ADMIN \n")])])]),s("ol",{attrs:{start:"24"}},[s("li",[e._v("cgroup_parent")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("指定一个容器的父级cgroup。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("cgroup_parent: m-executor-abcd \n")])])]),s("ol",{attrs:{start:"25"}},[s("li",[e._v("devices")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("设备映射列表。与Docker client的--device参数类似。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('devices:\n  - "/dev/ttyUSB0:/dev/ttyUSB0" \n')])])]),s("ol",{attrs:{start:"26"}},[s("li",[e._v("extends")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("这个标签可以扩展另一个服务，扩展内容可以是来自在当前文件，也可以是来自其他文件，相同服务的情况下，后来者会有选择地覆盖原有配置。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("extends:\n  file: common.yml\n  service: webapp \n")])])]),s("p",[e._v("用户可以在任何地方使用这个标签，只要标签内容包含file和service两个值就可以了。file的值可以是相对或者绝对路径，如果不指定file的值，那么Compose会读取当前YML文件的信息。"),s("br"),e._v("\n更多的操作细节在后面的12.3.4小节有介绍。")]),e._v(" "),s("ol",{attrs:{start:"27"}},[s("li",[e._v("network_mode")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("网络模式，与Docker client的--net参数类似，只是相对多了一个service:[service name] 的格式。"),s("br"),e._v("\n例如：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('network_mode: "bridge"\nnetwork_mode: "host"\nnetwork_mode: "none"\nnetwork_mode: "service:[service name]"\nnetwork_mode: "container:[container name/id]" \n')])])]),s("p",[e._v("可以指定使用服务或者容器的网络。")]),e._v(" "),s("ol",{attrs:{start:"28"}},[s("li",[e._v("networks")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("加入指定网络，格式如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("services:\n  some-service:\n    networks:\n     - some-network\n     - other-network \n")])])]),s("p",[e._v("关于这个标签还有一个特别的子标签aliases，这是一个用来设置服务别名的标签，例如：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("services:\n  some-service:\n    networks:\n      some-network:\n        aliases:\n         - alias1\n         - alias3\n      other-network:\n        aliases:\n         - alias2 \n")])])]),s("p",[e._v("相同的服务可以在不同的网络有不同的别名。")]),e._v(" "),s("ol",{attrs:{start:"29"}},[s("li",[e._v("其它")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("还有这些标签：cpu_shares, cpu_quota, cpuset, domainname, hostname, ipc, mac_address, mem_limit, memswap_limit, privileged, read_only, restart, shm_size, stdin_open, tty, user, working_dir"),s("br"),e._v("\n上面这些都是一个单值的标签，类似于使用docker run的效果。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("cpu_shares: 73\ncpu_quota: 50000\ncpuset: 0,1\n\nuser: postgresql\nworking_dir: /code\n\ndomainname: foo.com\nhostname: foo\nipc: host\nmac_address: 02:42:ac:11:65:43\n\nmem_limit: 1000000000\nmemswap_limit: 2000000000\nprivileged: true\n\nrestart: always\n\nread_only: true\nshm_size: 64M\nstdin_open: true\ntty: true \n")])])]),s("p",[e._v("关于配置文件的扩展写法会在有空的时候补上，写得太长了。"),s("code",[e._v("_(xз」∠)_")])])])}),[],!1,null,null,null);a.default=n.exports}}]);